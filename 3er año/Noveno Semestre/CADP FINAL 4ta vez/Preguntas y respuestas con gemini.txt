A. Falso, una lista tiene un solo tipo de dato, osea que es homogeneo.

B. Falso porque la funci√≥n tiene un retorno de un valor, en cambio los procedimientos no.

C. Verdadero porque la A imprime bien por ser una variable del programa principal, y la b al ser variable global se modifica en el procedimiento calculo sin haberla pasado por par√°metro, solo por haberla llamado. A: 40, B: 140.

D. Falso, para agregar sin necesidad de realizar un recorrido se a√±ade directamente adelante de todo.

E. Falso, un tipo de dato subrango solo puede ser tipos de datos que tienen una continuaci√≥n o siguiente valor, por ejemplo un integer es 1, 2, 3, 4. En cambio un dato real no tiene un valor siguiente definido.

F. Verdadero, en el tipo de dato real no es necesario especificar el numero con coma, si es un numero entero se pone.

G. No tengo idea

H. Falso, un programa correcto es el que funciona independientemente de cuantos modulos se usen

GEMINI:

### a. Listas heterog√©neas

* **Tu respuesta:** Falso. (Justificaci√≥n correcta).
* **Correcci√≥n:** ¬°Perfecto! **FALSO**. Una lista en Pascal es una estructura de datos *homog√©nea* porque todos sus nodos deben almacenar exactamente el mismo tipo de dato (aunque ese dato sea un registro complejo). 10/10.

### b. Funciones vs Procedimientos

* **Tu respuesta:** Falso.
* **Correcci√≥n:** **FALSO** tu Falso. ‚ùå La afirmaci√≥n es **VERDADERA**.
* **Justificaci√≥n de c√°tedra:** Todo m√≥dulo de tipo `function` (que retorna un solo valor en su nombre) se puede transformar en un `procedure`. ¬øC√≥mo? Simplemente agregando un par√°metro extra pasado por referencia (`var`) que act√∫e como el valor de retorno. ¬°Cualquier funci√≥n puede ser un procedimiento, pero no al rev√©s!

### c. Prueba de escritorio con variables globales

* **Tu respuesta:** Verdadero (A: 40, B: 140).
* **Correcci√≥n:** ¬°Cuidado ac√°! Es **FALSO**. ‚ùå Te olvidaste de que `a` tambi√©n se modifica adentro del procedimiento. Hagamos el rastro paso a paso:
1. Arranca: `a := 40`.
2. Llama a `calculo(a+10)`, es decir, `calculo(50)`. El par√°metro `c` vale 50.
3. Adentro del m√≥dulo: `b := a + 100`. Como `a` es la variable global (40), `b` pasa a valer 140.
4. Siguiente l√≠nea: `a := c + 10 + b`. Ac√° est√° la trampa. `c` es 50, `b` es 140. Entonces `a := 50 + 10 + 140`. **¬°La variable global `a` pasa a valer 200!**
5. Al imprimir, mostrar√°: `Valor de a: 200` y `Valor de b: 140`. Por lo tanto, el enunciado ment√≠a.



### d. Agregar al final de una lista

* **Tu respuesta:** Falso.
* **Correcci√≥n:** Es **VERDADERO**. ‚ùå
* **Justificaci√≥n:** Est√°s pensando en la t√©cnica cl√°sica donde solo ten√©s el puntero `L` (inicio) y ten√©s que iterar hasta encontrar el `nil`. Pero si en tu programa manten√©s un **puntero al √∫ltimo elemento** (suele llamarse `ult`), pod√©s enganchar el nuevo nodo directamente haciendo `ult^.sig := nuevo` en tiempo , sin recorrer nada. Es una t√©cnica de eficiencia clave en la materia.

### e. Subrango sobre Reales

* **Tu respuesta:** Falso. (Justificaci√≥n correcta).
* **Correcci√≥n:** ¬°Excelente! **FALSO**. Entendiste perfecto el concepto de "tipos ordinales". Los Reales no son ordinales (no tienen un "siguiente" discreto definido), por lo que es imposible hacer un subrango con ellos. 10/10.

### f. Invocaci√≥n de m√≥dulos y pasaje por referencia

* **Tu respuesta:** Verdadero.
* **Correcci√≥n:** ¬°Alerta roja! Es **FALSO**. üö®
* **Justificaci√≥n:** Mir√° bien el encabezado: `var b: real`. La palabra `var` significa que se pasa por *referencia*. La regla de oro en Pascal es que **no pod√©s pasar valores literales (como un 10) a un par√°metro por referencia**. El compilador necesita una *variable* (una caja de memoria) para poder guardar el resultado. Al intentar pasar el `10`, el programa tira error de compilaci√≥n inmediato.

### g. La ubicaci√≥n de la secci√≥n TYPE

* **Tu respuesta:** No tengo idea.
* **Correcci√≥n:** Es **FALSO**.
* **Justificaci√≥n:** La trampa est√° en la palabra "√∫nicamente". Si bien por orden l√≥gico en el programa principal se pone `const`, luego `type`, y luego `var`, tambi√©n **pod√©s declarar secciones `type` locales adentro de un procedimiento o funci√≥n** (antes del `begin` de ese m√≥dulo). Por lo tanto, no es el √∫nico lugar donde se puede incluir.

### h. Eficiencia vs Cantidad de m√≥dulos

* **Tu respuesta:** Falso.
* **Correcci√≥n:** Tu conclusi√≥n es correcta (**FALSO**), pero hay que ajustar la justificaci√≥n.
* **Justificaci√≥n de c√°tedra:** La cantidad de m√≥dulos no afecta la *eficiencia* (tiempo de ejecuci√≥n y uso de memoria). La modularizaci√≥n sirve para mejorar la legibilidad, la reutilizaci√≥n del c√≥digo y el mantenimiento. Un programa monol√≠tico (sin m√≥dulos) puede ser igual o m√°s r√°pido en ejecutarse que uno recontra modularizado, siempre y cuando el *algoritmo* usado sea el mismo.