A. Falso.

B. Falso, un programa correcto es aquel que funciona correctamente como se pide. Pero usar parametros, modulos, etc; no asegura ni garantiza que el programa sea correcto.

C. Falso, la invocacion al modulo es invalida ya que la funcion "otro" esta dentro del proceso calcular. En este caso el 칰nico que sabe usar la funcion previamente dicha es justamente el proceso calcular.

D. Verdadero, siempre y cuando la lista quede reordenada con los punteros bien.

E. Falso, siempre se va a ejecutar al menos 1 sola vez ya que la validaci칩n se hace en el until luego de haberse ejecutado las instrucciones.

F. Falso, imprime: a: 175, b: 20, c: 10

----------------------------------------------------------

GEMINI:

A. Tu respuesta: Falso. (Sin justificar).

Correcci칩n: 춰Es FALSO! Pero te falt칩 la justificaci칩n (y en el parcial sin justificaci칩n no suma puntos).

Justificaci칩n de c치tedra: No siempre es obligatorio hacer un new. A un puntero se le puede asignar el valor nil (para inicializarlo vac칤o) o se le puede asignar la direcci칩n de memoria de otro puntero que ya fue creado (ejemplo: puntero1 := puntero2;). Solo se usa new cuando quer칠s pedir un espacio de memoria din치mica nuevo.

B. Tu respuesta: Falso (con excelente justificaci칩n).

Correcci칩n: 춰10/10! Lo explicaste perfecto. Modularizar y parametrizar te da un programa m치s legible, m치s f치cil de mantener y mejor dise침ado, pero si tu l칩gica matem치tica o algor칤tmica est치 mal, el programa va a seguir siendo incorrecto.

C. Tu respuesta: Falso (con excelente justificaci칩n).

Correcci칩n: 춰Otro 10/10! Entendiste a la perfecci칩n la regla de Alcance (Scope). Como la funci칩n otro est치 declarada adentro del procedimiento calcular, es un m칩dulo local. El programa principal no tiene ni idea de que existe.

D. Tu respuesta: Verdadero.

Correcci칩n: 춰Alerta roja! 游뚿 Es FALSO.

Justificaci칩n: 쯈u칠 pasa si la lista est치 vac칤a (L = nil)? Si intent치s acceder a L^.sig para reordenar los punteros y borrar el primer elemento de una lista que no tiene nada, el programa crashea con un Runtime Error. Siempre que te digan "siempre es posible" en estructuras din치micas, desconfi치 y pens치 en el caso de la estructura vac칤a.

E. Tu respuesta: Falso (con excelente justificaci칩n).

Correcci칩n: 춰10/10! La ten칠s clar칤sima. Al ser una estructura de post-condici칩n, eval칰a al final, por lo que el cuerpo se ejecuta m칤nimo 1 vez.

F. Tu respuesta: Falso (con trace: a: 175, b: 20, c: 10).

Correcci칩n: La respuesta es FALSO, pero tu prueba de escritorio tiene un error muy sutil por una de las trampas m치s crueles de la materia: el Aliasing (cuando dos nombres apuntan a la misma caja de memoria).

Vamos a destriparlo paso a paso:

Programa principal: b := 20; y luego c := 15; (porque 20 - 5 = 15).

Llamamos a calcular(b, c);. El par치metro b (local) recibe 20 por valor. El par치metro x recibe a c por referencia. 춰Atenci칩n ac치! x y la variable global c son la misma caja de memoria.

Adentro de calcular: x := 10;. Como x es c, la variable global c ahora vale 10.

Siguiente l칤nea: c := c + b;. Usa la c global (10) y la b local (20). La c global ahora vale 30.

Siguiente l칤nea: a := (b + x) * 5;. Ac치 te equivocaste vos. Como x es el mismo espacio de memoria que c, al haber cambiado c a 30, x tambi칠n vale 30. La cuenta es: a := (20 + 30) * 5. Esto da 250.

칔ltima l칤nea: b := (a + b) MOD 10;. b local pasa a valer (250 + 20) MOD 10, que da 0.

Al salir e imprimir, quedan las variables globales: a vale 250, b vale 20 (nunca se modific칩) y c vale 30. La salida real es 250, 20, 30.